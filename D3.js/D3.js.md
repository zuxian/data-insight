

###  导语

D3.js（Data-Driven Documents）通过D3提供的接口来基于数据操控文档的各个图元。

- 可视化基本图表：柱状图、折线图、饼图、散点图、力导图等。可定制化小细节。
- 数据：读取CSV、 JSON、层级数据、网络数据等。
- 动画、 交互。
- D3.js中的常用接口

>  SVG – 可缩放矢量图形（ Scalable Vector Graphics）

SVG是D3.js主要操作的对象‘画布’，D3.js获取svg对象： `const svg = d3.select(‘svg’);` 

SVG同时也是一个容器，用于包含画在上面的各个图元。

SVG作为矢量图，不会随着图片的缩放而发生失真；

![](images/svg.png)

### 语法基础

D3查询SVG：d3.select(‘#rect1’)、d3.selectAll(‘.class1’)   【ID前加‘#’， Class前加‘.’ ，标签名前不加符号】

D3 添加&删除 SVG元素：  `d3.select(‘#mainsvg’).append(‘g’).attr(‘id’, ‘maingroup’)`，	element.remove()



> D3设置SVG中的属性，常见的属性：

• id, class（可使用.attr设置）
• x, y, cx, cy （注意屏幕的坐标系）
• fill, stroke
• height, width, r (圆的半径)
• transform -> translate, rotate, scale  

`  <rect id='rect3' class='class1' stroke='black' height='200' width='66' fill='#7289AB' x='300' y='-100'>  `

链式调用： selection.attr(…).attr(…).attr(…)，返回的是选择的图元本身



> 数据的读取  
>

CSV数据：第一行为属性列表，后续每行对应一‘条’数据。CSV本质上是纯文本，区别于EXCEL的格式。

`d3.csv(‘path/to/data.csv’).then( data => { ... } )`



> 数值计算

d3.max(array) -- 数组中的最大值、d3.min(array) -- 数组中的最小值、d3.extent(array) -- 返回最小值与最大值



> 比例尺  
>

常用于映射数据、创建坐标轴

d3.scaleLinear()：线性比例尺，返回的是一个函数。

domain().range()：设置比例尺的定义域和值域，都是连续的，需分别给出最大值与最小值。

​								`d3.scaleLinear().domain([min_d, max_d]).range([min, max])`  

d3.scaleBand()： 条带比例尺，返回的是一个函数。

Band比例尺的定义域是离散的，值域是连续的。`d3.scaleBand().domain(array).range([min, max])`  

scale.padding(0.1)： 设置条带的间距占各自区域的比重。

scale.bandwidth():   返回条带的长度。



> 坐标轴

任何坐标轴在初始化之后会默认放置在坐标原点，需要进一步的平移。

坐标轴本质上是图元的集合。
• `d3.selectAll('.tick text').attr('font-size', '2em’);`
• .tick是D3对于坐标轴定义的统一class

坐标轴的标签： 

通过对坐标轴的`<g>`标签 `.append(‘text’)`来实现
• （左）纵轴坐标需要 `.attr(‘transform’, ‘rotate(-90)’)` 来旋转  

```js
//  定义坐标轴（返回仍是函数）
const yAxis = d3.axisLeft(yScale);    // 左侧坐标轴
const xAxis = d3.axisBottom(xScale);  // 底侧坐标轴

//  绘制坐标轴
const yAxisGroup = g.append('g').call(yAxis);
const xAxisGroup = g.append('g').call(xAxis);

// 画布主体需要Margin
const margin = {top: 60, right: 30, bottom: 60, left: 200}
// 计算实际操作的 inner 长/宽
const innerWidth = width - margin.left - margin.right;
const innerHeight = height - margin.top - margin.bottom;
// 在SVG下额外定义一个组作为新的根节点
const g = svg.append('g').attr('id', 'maingroup').attr('transform', `translate(${margin.left}, ${margin.top})`);


```

selection.call(…)：定义一个空白的`<g>`，输入为另一个函数，用该函数修改`<g>`

坐标轴通常初始化在所在父节点的左上角，需要在画布margin一段距离画图



> Data-Join：  绑定数据与图元  
>

`d3.selectAll(‘.class’).data(myArray).join(‘图元’).attr(d => …)`

myArray的每条数据会与一个图元绑定。    .join(…)会根据数据的条目补全or删除图元。  

```js
mainGroup.selectAll('rect').data(data).join('rect')
.attr('height', yScale.bandwidth())
.attr('width', d => xScale(d.globalsale))
.attr('x', 0).attr('y', d => yScale(d.platform));
```

![](images/datajoin.png)

> 颜色 – ‘fill’属性



>   D3提供的各种色盘  
>

https://github.com/d3/d3-scale-chromatic

离散-->离散的映射：`const color = d3.scaleOrdinal().domain(naiveKeys).range(d3.schemeSet3)`





###  动画

> transition

D3的selections后调用transition，将后续的.attr(…)加以动画效果，  支持链式调用  

用2000毫秒把选择图元的宽变成400：

`d3.select("#my_rect").transition().duration(2000).attr("width", "400");` 



>   ‘ease’   动画过渡方式，作用在transition对象后    

`d3.select("#my_rect").transition().duration(2000).ease(d3.easeLinear).attr(…)`

 d3.easeCubic 默认，加速->减速、d3.easeLinear 线性、 d3.easeElastic 弹射



> 动画 – 同步  
>

```js
//  所有绑定的图元会同步播放动画
rects.transition(transition).attr(…).attr(…)
circles.transition(transition).attr(…).attr(…)

// 等待一个transition全部相关的图元执行完毕
await transition.end();

//  柱形图的 长方块与文案一起变动
(async () => {
    while(true){
        data.forEach(d => { d.value = Math.random() * 20; });
        let transition = d3.transition().duration(1000)//.ease(d3.easeElastic);

        rects.transition(transition).attr('width', d => xScale(d.value))
        .attr('fill', () => d3.interpolateRainbow(Math.random()));

        texts.transition(transition).attr('x', d => xScale(d.value))
        .text(d => formatPercent(d.value));

        await transition.end();
    }
})()
```

> 数字的格式化：  d3.format(‘.2f’)(666.666)  
>

实现动态散点图

```js
const renderupdate = async function(seq){
    const g = d3.select('#maingroup');
    d3.select('#date_text').text(seq[0]['日期']);
    let transition = d3.transition().duration(aduration).ease(d3.easeLinear); 

    let circleupdates = g.selectAll('circle').data(seq).join('circle')
    .attr('fill', d => color[keyValue(d)] )
    .attr('opacity', .8)
    .transition(transition)
    .attr('cy', d => yScale(yValue(d)))
    .attr('cx', d => xScale(xValue(d))) 
    .attr('r', c => rValue(c));

    let textupdates = g.selectAll('.province_text').data(seq).join('text')
    .attr("class", "province_text")
    .attr("dy", "1em")
    .style("text-anchor", "middle")
    .attr("fill", "#333333")
    .text( d => keyValue(d))
    .transition(transition)
    .attr('x', d => xScale(xValue(d)))
    .attr('y', d => yScale(yValue(d)));

    await transition.end();
};

for(let i = 0; i < sequential.length; i++){ await renderupdate(sequential[i]); }
```

###  Path

图元Path： Path的常见属性。   ‘d’属性-‘笔画’的设置规则。
D3.js的‘d’属性接口：d3.line()     d3.arc()
基于d3.line()绘制折线图：• 时间数据的处理与时间比例尺。  • 单一图元的Data-Join， selection.datum(…)。
基于d3.arc()绘制饼图：     • 离散比例尺与D3.js的配色方案； • d3.pie()  

> **`<path>`  属性**

d： `<path>`勾勒的方式，即‘笔画’。

```js
• M = moveto(M X,Y) ：将画笔移动到指定的坐标位置
• L = lineto(L X,Y) ：画直线到指定的坐标位置
• H = horizontal lineto(H X)：画水平线到指定的X坐标位置
• V = vertical lineto(V Y)：画垂直线到指定的Y坐标位置
• C = curveto(C X1,Y1,X2,Y2,ENDX,ENDY)：三次贝赛曲线
• S = smooth curveto(S X2,Y2,ENDX,ENDY)：平滑曲率
• Q = quadratic Belzier curve(Q X,Y,ENDX,ENDY)：二次贝赛曲线
• T = smooth quadratic Belzier curveto(T ENDX,ENDY)：映射
• A = elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y)：弧线
• Z = closepath()：关闭路径
```

• fill： 填充颜色。
• stroke：描边颜色。
• stroke-width：描边宽度。
• transform：变换

```html
<svg width="100px" height="100px">
   <path d="M0 0 H 90 V 90 H 10 L 10 10" />     // 直线命令 --》 绘制正方形
</svg>

// 三次贝塞尔曲线C-->起点基于‘M’命令, C x1 y1, x2 y2, x y：M起点开始的曲线。(x,y)：曲线的终点.
// 曲线沿着起点到第一控制点的方向伸出，逐渐弯曲，然后沿着第二控制点到终点的方向结束。
<path d="M130 110 C 120 140, 180 140, 170 110" stroke="black" fill="transparent"/>

```

![1675304700026](./images/贝塞尔.jpg)

> **D3.js的‘d’属性接口**  

d3.line(…).x(…).y(…)        用于将多个点依次连线，如折线图。
d3.arc(…).innerRadius(…).outerRadius(…)       弧，用于饼图。
d3.geoPath().projection()        用于地理、地形数据。
d3.area()         区域的‘d’属性，如主题河流。

- **d3.line().x(…).y(…).curve(d3Curve)**  

```js
const data = [{'x': 100, 'y': 100},{'x': 200, 'y': 300},{'x': 300, 'y': 50},{'x': 400, 'y': 600}];
const pathLine = d3.line().x(d => d.x).y(d => d.y).curve(d3.curveBasis); 
svg.append('path').attr('stroke','black').attr('fill','none').attr('d',pathLine(data))
```

- **d3.arc().innerRadius(100).outerRadius(200).padAngle(0.1)** 

  圆弧的内半径、外半径，圆弧两侧的预留间隔padAngle，函数入参为一个对象--起始和终止角度  

```js
const part3 = {'startAngle': 4.34, 'endAngle': 6.283185307179586};
const pathArc3 = d3.arc().innerRadius(0).outerRadius(160).padAngle(0.1);
svg.append('path').attr('stroke', 'black').attr('fill', 'steelblue').attr('transform', 'translate(800, 400)').attr('d', pathArc3(part3));
```

>   **d3.line()绘制折线图**

- **时间数据处理：时间比例尺  d3.scaleTime()**   

d3.scaleTime().domain(d3.extent(data.map(d => d.day))).range([0, 1600]);
• 设置时间比例尺的定义域与值域。
• JSt的Date对象支持‘顺序’、 ’>’与’<’，因此可按照数值型变量基于d3.extent接口计算两个端点值。

```js
data.forEach(d => { d.day = new Date(d.day); d.sale = +(d.sale); })
xScale.domain(d3.extent(data.map(d => d.day))).range([0, innerWidth]).nice();
const timeFormat = d3.timeFormat('%b-%d')   // 返回一个函数：输入日期  --》 ‘月-日’格式。
const xAxis = d3.axisBottom(xScale).ticks(15).tickFormat(timeFormat);
```

- **selection.datum()     对单一图元绑定单一数据**

.data(…)     将一批图元与一批数据绑定
.datum(…)  给特定的一个图元绑定一个数据，直接把一个数组作为单一图元绑定给一个`<path>`即可。  

```js
const line = d3.line().x(d=>xScale(d.day)).y(d=>yScale(d.sale)).curve(d3.curveLinear);
mainGroup.append('path').datum(data).attr('fill','none').attr('d', line).attr('stroke','black')
```

> **d3.arc()绘制饼图**  

- d3.pie()：由‘数值’到‘比例’的转化。把比例映射到[0, 2Pi]的弧度区间

![1675318482225](images/1675318482225.png)

- **scaleOrdinal   离散比例尺**与D3.js的配色方案  `d3.scaleOrdinal().domain(…).range(…)`

D3.js的配色方案d3.schemeSet1、 d3.schemeSet2、 d3.schemeSet3。是数组。不够可互相拼接

```js
const pie = d3.pie().value(d => d.population);
const arcData = pie(data);

const color = d3.scaleOrdinal().domain(data.map(d => d.city))
						  .range(d3.schemeSet2.concat(d3.schemeSet3));

const path = d3.arc().innerRadius(60).outerRadius(260);

svg.selectAll('path').data(arcData).join('path').attr('d', path)
.attr('transform', `translate(${width / 2}, ${height / 2})`)     // 圆中心
.attr('fill', d => color(d.data.city));

const arcOuter = d3.arc().innerRadius(280).outerRadius(280);
svg.append('g').attr('transform', `translate(${width / 2}, ${height / 2})`)
.selectAll('text').data(arcData).join('text')
.attr('transform', d => `translate(${arcOuter.centroid(d)})`)    // 每个圆弧的中心
.attr('text-anchor', 'middle').text(d => d.data.city);
```

- **为饼图添加文字标签**

`const arcOuter = d3.arc().innerRadius(280).outerRadius(280);`    定义一个完全‘贴’在外围的arc函数。`arcOuter.centroid({‘startAngle’: 0, ‘endAngle’: 1.186})`     返回输入圆弧的中心点坐标。



###  地图与地理

- JSON与geoJSON：• json的数据格式与读取。• geoJson的数据格式。

- d3-geo：
  • 地图数据(经纬度)到画布的映射(投影)： d3.geoPath().projection(…)。
  • ‘d’属性接口： d3.geoPath()。

- 基于d3-geo绘制北京市地图。

- d3-contour： 等值线数据的输入与处理。

-  基于d3-contour与d3-geo绘制等值线图：
  • d3.scaleSequential：基于插值的连续比例尺。
  
  

>  geoJson
>

一个geoJson包括如下内容：
• ‘type’：‘FeatureCollection’
• ‘features’，一个数组，包含若干个形状的几何与形状的属性：
	• type：‘Feature’,
	• geometry： 几何信息，是一个对象。
	• properties： 属性，是一个对象，如包含邮政编码、地区名称、人口、气候、栖息物种等。



将geoJson中的几何数据(geometries)经纬度，映射到画布上，需要投影。

- d3.geoNaturalEarth1()：  返回的投影函数，输入为 geoJson含经纬度的点，  输出：画布含横纵坐标点

- 投影函数的定义域和值域：  `proj.fitSize([width, height], geoJson)`  



> d3.geoPath()  
>

d3.geoPath()：返回一个函数，输入geoJson的一个‘Feature’，输出`<path>`的‘d’属性

`d3.geoPath()(geoJson.features[0]) // M713.617444890755,527.4596`  

d3.geoPath().projection(…)，  生成的‘d’属性，设置投影。  



> 基于d3-geo绘制地图

```js
const projection = d3.geoNaturalEarth1();     // 选择投影方式
projection.fitSize([width, height], data);    // 设置画布大小
const path = d3.geoPath().projection(projection); // 返回函数，输出<path>的‘d’属性
console.log(path(data.features[0]))    // 打印第一个地区图元投影之后的数据

svg.selectAll('path').data(data.features).join('path')
 										 .attr('stroke', 'black').attr('fill', 'none')
										 .attr('d', path).attr('id', d => d.properties.name);
```

- 地图添加标签  ----  数据中心centroid： 

```js
.attr('transform', d => `translate(${projection([d.properties.centroid[0], d.properties.centroid[1]])})`)
```



> d3-contour： 等值线数据的输入与处理

D3.js的‘contour’模块作用：在输入‘矩阵’的元素(左)之间形成轮廓(中)，将值(value)
相近的元素包围在一起，最终(拟合)得到每个轮廓的几何(右)。

![](images/contour.png)

轮廓线输入的JSON数据格式：
• 矩阵的宽 width、  • 矩阵的高 height、  • 矩阵的值：数值的数组（一阶）。
• 行主序：即(𝑖, 𝑗)表示数组中的第(𝑖 + 𝑗 × 𝑤𝑖𝑑𝑡ℎ)个元素。

- d3.contours()： 返回等值线生成函数，将矩阵转换为几何，输入数组，输出geoJson的geometry对象

- d3.contours().size([width, height])：   设置矩阵的行数与列数 ([n, m])  
- d3.contours().thresholds( array )：     设置轮廓的阈值。阈值数量==轮廓数量，即每个阈值对应一个轮廓。
  • 值(value)  >=  某一个阈值，会被包含在这个阈值的轮廓。
  • 相邻却属于不同阈值(轮廓)的元素间，使用marching squares分界

- d3.contours().smooth(true/false)：   是否平滑轮廓？   轮廓本质上是‘水平、竖直、斜’三种移动方式  

```js
const contours=d3.contours().size([width,height]).thresholds(thresholds).smooth(true);
const geoPolygons = contours(data.values);
```



>  d3-contour – 轮廓geoJson的投影

d3.contour()导出的轮廓数据(geoJson)调整为画布的尺寸：需(d3-geo-projection)投影做‘比例尺’映射并把geoJson补全，需d3.geoPath将geoJson转换为`<path>`的‘d’属性。

- 插值的连续比例尺  `d3.scaleSequential( interpolator ).domain([min, max]) ` 

  比如颜色分配： `d3.scaleSequential(d3.interpolatePlasma).domain(d3.extent(data.values)); `



>  d3-contour与d3-geo绘制等值线图

```js
// 构造等值线生成函数;
const contours=d3.contours().size([width,height]).thresholds(thresh).smooth(true);
const geoPolygons = contours(data.values);

// 构造GeoJson并FitSize。
const geoJson = { "type": "FeatureCollection", "features": [] };
for (const geoPolygon of geoPolygons) {     // 补全数据，成为完整的geoJson
    geoJson.features.push({ 'geometry': geoPolygon });
}
const projection = d3.geoNaturalEarth1();   // 投影函数
projection.fitSize([width, height], geoJson);  // 比例尺
const path = d3.geoPath();
path.projection(projection);   // 将geoJson转换为`<path>`的‘d’属性

// Data-Join; 
svg.selectAll('.myPath').data(geoPolygons).join('path')
.attr('class', 'myPath').attr("fill", d => color(d.value))
.attr("stroke", "white").attr("stroke-width", 1).attr('opacity', 0.3)
.attr('d', d => path(d));
```



###  交互

`selection.on(‘eventName’, (event, d) => {触发动作}) ` 

```js
// 点击，随机改变颜色
d3.select("#my_rect").on('click', (event, d) => {
	 d3.select(event.currentTarget).attr('fill', d3.interpolateRainbow(Math.random()));
});
```

- click：鼠标左键单击。
-  mouseover：鼠标移‘入’某个图元。
-  mouseout：鼠标移‘出’某个图元。
- keydown：某一个键盘的‘键’被按下。
-  contextmenu：鼠标右键单击。需阻止浏览器的默认行为 event.preventDefault();
-  mousemove：鼠标移动。

>  D3-Tip悬浮框

D3-Tip用于快速生成、添加或隐藏标签，不是D3.js自带的接口，导入需要额外的JS脚本。

- 初始化一个Tip：`const tip = d3.tip().html((event, d) => d.properties.name)`

  告知Tip要如何根据输入的数据显示标签， (event, d) => d.properties.name

- svg.call(tip)：类似坐标轴的添加，正式渲染出Tip。
- tip.show(event, d)：基于事件与图元绑定的数据，显示Tip。
- tip.hide(event, d)：基于事件与图元绑定的数据，隐藏Tip。

```js
const tip = d3.tip().html((event, d) => d.properties.name);
svg.call(tip);
tip.attr('class', 'd3-tip');

mainGroup.selectAll('path').data(data.features).join('path')
    .attr('stroke', 'black').attr('fill', 'white')
    .attr('d', path)
    .attr('id', d => d.properties.name)
    .on('mouseover', tip.show)
    .on('mouseout', tip.hide);
```

> 键盘事件 

d3.select(‘body’).on(‘keydown’, f);      通过event.keyCode获得键值。

```js
let isTransitioning = false;
const step = 60;
const duration = 1000;
const keyTranslate = (at, s) => {
    isTransitioning = true;
    let transition = d3.transition().duration(duration).on('end', () => isTransitioning = false); 
    d3.select('#keyele').transition(transition).attr(at, function(){
        return +d3.select(this).attr(at) + s;
    });
}  // 通过 W/A/S/D   控制图元 上下左右 移动
d3.select('body').on('keydown', async function(event){
    if(isTransitioning){ return;  }
    if(event.keyCode === 87){ keyTranslate('cy', -step); }      // W
    else if(event.keyCode === 83){ keyTranslate('cy', step); }		// S
		else if(event.keyCode === 65){ keyTranslate('cx', -step); }		// A
    else if(event.keyCode === 68){  keyTranslate('cx', step); }		// D  
});
```

###  数据堆叠

> D3.js的‘stack’数据堆叠： 数据堆叠后的格式。 堆叠的取值与顺序。
> ‘stack’实现堆叠柱状图：嵌套数组的最大值计算。   Data-Join嵌套、继承与传递。
> stack’实现主题河流：  区域的‘d’属性接口： d3.area()。



定义数据堆叠函数。 `let stack = d3.stack()；  let stackedData = stack(data)`
返回结果以属性为单位，将数据分堆。每堆含若干对应属性堆叠后的位置--起点和终点



数据原本的形式：四条数据、每条有四个要堆叠的属性。

![1675777536216](C:/Users/fzuxi/AppData/Roaming/Typora/typora-user-images/1675777536216.png)



![](images/stack-data.png)



- 堆叠的取值： stack.keys([“apples”, “bananas”]);    // 只堆叠苹果和香蕉

- 堆叠的顺序：`stack.orders(d3.stackOrderNone); `     // 随Key的顺序。
  						`stack.orders(d3.stackOrderAscending);`     // 按照堆叠值升序

- 取嵌套数组的最大值：  `d3.max([[1,2,3], [666,233,999], [110,120,119]], a => d3.max(a))`

```js
const yScale = d3.scaleLinear()
.domain([0, d3.max(naiveStack, d => d3.max(d, subd => subd[1]))])
.range([innerHeight, 0]).nice();
```

- Data-Join嵌套、传递与继承：

selection.data(data)： 数据数组会被分给各个绑定的图元，

`selection.data(data).attr(…).selectAll(…).data( d => d ).join(…)`：把父节点的数据进一步按数组拆分，分给各个后续的子节点。

图元绑定的数据会被‘.append(…)’添加的子节点继承：
`let gs = svg.selectAll(‘g’).data(data).join(‘g’);`     基于Data-Join添加若干`<g>`。
`gs.append(‘rect’);`     为每个`<g>`添加矩形，每个矩形绑定的数据随`<g>`。



- 基于‘stack’实现堆叠柱状图

```js
var naiveStack = d3.stack().keys(naiveKeys).order(d3.stackOrderNone)(naiveData);

g.selectAll('.datagroup').data(naiveStack).join('g')
.attr('class', 'datagroup')
.attr('fill', d => color(d.key))
.selectAll('.datarect').data(d => d).join('rect')
.attr('class', 'datarect')
.attr('y', d => yScale(d[1]))
.attr('x', d => xScale(xValue(d.data)))
.attr('height', d => yScale(d[0]) - yScale(d[1]))
.attr('width', xScale.bandwidth());
```



> d3.area(…)

- let path = d3.area()      ‘area’生成函数，输入为数组，输出为`<path>`的‘d’属性值。
  • path.x(d => xScale(d.data.ym)) 	// 设置x轴的取值随绑定数据的.data.ym属性。
  • path.y1(d => yScale(d[1])) 	// 设置上界y轴。
  • path.y0(d => yScale(d[0]))	 //设置下界y轴。

- path.curve(…)：
  • 设置‘area’上边界与下边界的拟合方式，同d3.line().curve()。
  • e.g., path.curve(d3.curveCardinal.tension(0.5));  

```js
// define an area generator;
let area = d3.area().x(d => xScale(d.data.ym))
  .y1(d => yScale(d[1])).y0(d => yScale(d[0])).curve(d3.curveCardinal.tension(0.5));

// data-join;
g.selectAll('.riverPath').data(stackedData, d => d.key).join('path')
.attr('class', 'riverPath').attr('d', area).attr('fill', d => color(d.key));
```

直方图 d3.histogram: 用于将数据按照某一属性分布在不同的区域
饼图 d3.pie: 用于将数据映射到圆周的各个弧度

###  层次数据

- D3.js的层级数据可视化：
	• 层级数据的数据结构。
	• d3.hierarchy：层级数据的处理与预计算。
	• d3.tree & d3.partition：层级数据的划分与映射。
- 基于‘d3.tree’实现树状图：  d3.linkVertical() & d3.linkHorizontal()。
- 基于‘d3.partition’实现冰锥图与日晕图



> **d3.hierarchy(data).sum(…).sort(…)**

保持数据的原始结构，转换成D3中的hierarcy对象，返回的数据带有若干接口

height：所在节点的高度， depth：所在节点的深度
children：原本数据的格式被保留， parent：到父节
data：到原始数据的映射， value：节点的参考值。

- .sum(…)：节点的取值，父节点的取值等于子节点的取值之和

- .sort(…)：对每个父节点下设的子节点们进行排序

![](images/hierarchy.png)

- d3.hierarchy(data).descendants()： 把层级结构‘拍平’，广度优先返回层级结构中的所有节点。
  • 用于节点相关的Data-Join，如添加代表节点的图元（矩形、圆） 等。

- d3.hierarchy(data).links()： 返回层级结构中的所有链接，以‘source’和‘target’的形式。
  • 主要用于连线相关的Data-Join，如添加节点间的连线。

  

> **d3.tree：树形图的映射函数**

tree(d3.hierarchy(data))：  把d3.hierarchy(…)返回的数据在画布上划分， 得到每个节点在画布中的位置。

- tree.size([width, height])：树形区域的比例尺映射，即树形结构要画到多大的画布上。
  `d3.tree().size([innerWidth, innerHeight])(d3.hierarchy(data));`



> **d3.partition：层级区域的映射函数**

partition(d3.hierarchy(data))：把d3.hierarchy(…)返回的数据在画布上划分， 得到每个节点的位置和所占区域，所占区域的比例随层级的值。  区域由四个值确定， 但并不一定矩形。

- partition.size([width, height])：划分的比例尺映射

```js
let hiedata = d3.hierarchy(data).sum(d => d.population)
																.sort((a, b) => b.population - a.population)
root = d3.partition().size([2 * Math.PI, 500])(hiedata)   // 冰锥图
// root = d3.partition().size([height, width])(hiedata)   // 掰成一圈 --->  日晕图
```
-   ‘d3.partition’实现冰锥图： 根据各个节点所占的区域，直接每个节点Data-Join矩形图元  

```js
g.selectAll('.datarect').data(root.descendants()).join('rect')
.attr('class', 'datarect').attr('x', d => d.y0).attr('y', d => d.x0)
.attr('height', d => d.x1 - d.x0).attr('width', d => d.y1 - d.y0).attr("fill", fill);
```

- ‘d3.partition’实现日晕图

​    d3.arc(…)：根据绑定的数据调节起始角度、终止角度、 内半径与外半径。变量d是每个弧绑定的数据

![](images/日晕图.png)

- 冰锥图与日晕图的**文本**

  不显示过长文本或小区域的文本：`root.descendants().filter(d => d.depth && (d.x1 - d.x0) > Math.PI / 65 && d.data.name.length < 15)`

```js
.attr("transform", function (d) {
    const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
    const y = (d.y0 + d.y1) / 2;
    return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180}) translate(0, 5)`;
})
```



>   **‘d3.tree’实现树状图**  
>

需要用到的图元：• 圆(Data-Join)、  • 文本(Data-Join)、   • 连接线(d3.linkVertical)。

- d3.linkVertical、d3.linkHorizontal ：返回函数，输入两个节点， 输出`<path>`的‘d’属性，两者笔顺不同。

```js
const data1 = {'source': {'x': 100, 'y': 100}, 'target': {'x': 600, 'y': 900}};
const pathH = d3.linkHorizontal().x(d => d.x).y(d => d.y);
const pathV = d3.linkVertical().x(d => d.x).y(d => d.y);
svg.append('path').attr('d', pathH(data1)).attr('stroke', 'steelblue');
svg.append('path').attr('d', pathV(data1)).attr('stroke', 'green');
```

将d3.hierarchy(data).links()返回层级结构中的所有链接，使用d3.linkVertical连接起来

```js
g.selectAll("path").data(root.links())
.join("path").attr("fill", "none").attr("stroke", "black").attr("stroke-width", 1.5)
.attr("d", d3.linkVertical().x(d => d.x).y(d => d.y));
```

- 每个节点d3.hierarchy(data).descendants() --> 圆点(Data-Join)

```js
g.selectAll('circle').data(root.descendants()).join('circle')
										 .attr("stroke-width", 3).attr("fill", fill)
										 .attr('cx', d => d.x).attr('cy', d => d.y).attr("r", 6);
```

- 文本的属性

```js
g.selectAll('text').data(root.descendants()).join('text')
.attr("text-anchor", d => d.children ? "end" : "start") // 根节点文本向外、非根节点文本向内
.attr('x', d => d.x).attr('y', d => d.y + (d.children ? -10 : 10))
.text(d => d.data.name)
.attr('writing-mode', 'vertical-rl')  // 文本的行文方向为垂直
.attr('text-orientation', 'upright')
```



###  网络数据

- 网络数据的数据结构？
- 基于`<path>`实现弧长连接图： `<path>`的弧线命令。
- 基于‘d3.chord’与‘d3.ribbon’实现弦图：d3.chord预‘分配’圆周、d3.ribbon生成弦的‘d’属性。
-  D3.js力模拟基础：
  • d3-force的总体配置。
  • 不同力的作用与‘Tic-Toc’。
-  基于‘d3-force’实现力导图



















![](images/all-api.png)































